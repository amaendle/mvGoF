% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mvGOV.R
\docType{package}
\name{mvGoF}
\alias{mvGoF}
\alias{mvGoF-package}
\title{mvGoF: A package for computating several multivariate EDF goodness of fit statistics.}
\description{
Multivariate versions of the popular EDF statistics by \emph{Cramér-von Mises}, \emph{Anderson-Darling} and \emph{Kolmogorov-Smirnov} are supported.
}
\section{List of public functions}{

\itemize{
 \item{"\code{\link{AD.stat}}"}{ Anderson-Darling}
 \item{"\code{\link{CvM.stat}}"}{ Cramér-von Mises}
 \item{"\code{\link{biKS.stat}}"}{ bivariate Kolmogorov-Smirnov}
 \item{"\code{\link{rosenblatt.norm}}"}{ Rosenblatt's transformation for normally distributed data}
}
}
\examples{
# Evaluate percentiles of the distribution by Monte-Carlo simulation
# sampling from independent uniforms 0-1 for F_0 specified completely by H_0
ns <- c(10:15,20,25,30,40,50,60,80,100,150,200,300)
alphas <- c(0.25,0.2,0.15,0.1,0.05,0.025,0.01,0.005,0.0025,0.001)
rp <- 100 #replications, usually a larger number,e.g. 10000
n < - 10
KS.n10.sims <- rep(NA,rp) #matrix(NA, 10, 2, dimnames = list(c(1:10),c("X", "Y"))) #
AD.n10.perm1.sims <- rep(NA,rp)
CvM.n10.sims <- rep(NA,rp)
set.seed(14072016)
for (i in 1:rp) {
  rbts <- matrix(runif(2*n), n, 2, dimnames = list(c(1:n),c("X", "Y")))
  KS.n10.sims[i] <- biKS.stat( rbts  )
  AD.n10.sims[i] <- AD.stat( rbts  )
  CvM.n10.sims[i] <- CvM.stat( rbts  )
}
quantile(KS.n10.sims,probs=(1-alphas))
quantile(AD.n10.sims,probs=(1-alphas))
quantile(CvM.n10.sims,probs=(1-alphas))

# evaluate critical values
n <- 15 # for a rather small sample size
btnr <-500 # nr of iterations
# generate data
mu0 <- rep(0,2)
Sigma0 <- diag(0.5,2,2)+matrix(0.5,2,2)
stats.KS.n15.cv <- rep(NA, btnr)
stats.AD.n15.cv <- rep(NA, btnr)
stats.CvM.n15.cv <- rep(NA, btnr)
for (i in 1:length(stats)) {
  rbts <- rosenblatt.norm(  mvrnorm(n, mu0, Sigma0)  ,mu0,Sigma0)

  stats.KS.n15.cv[i] <- biKS.stat( rbts  )
  stats.AD.n15.cv[i] <- AD.stat( rbts  )
  stats.CvM.n15.cv[i] <- CvM.stat( rbts  )
}
# Pearson-Anpassung
library("PearsonDS")
biz0ppar <- pearsonFitML(stats)
# kritische Werte nach emp. Quantil bzw. Pearson
quantile(stats,probs=0.95)
qpearson(p=0.95,params=biz0ppar)

#evaluate power of statistics
#set parameters for alternative distribution
eps <- 0.1 #c(0.1,0.2,0.4)
mu <- c(3,3)
t1.KS.n15.sims <- rep(NA, btnr)
t1.AD.n15.sims <- rep(NA, btnr)
t1.CvM.n15.sims <- rep(NA, btnr)
for (i in 1:btnr) {
  rbts <- rosenblatt.norm(  ((1-eps)*mvrnorm(n, mu0, Sigma0) + eps*mvrnorm(n, mu, Sigma0))  ,mu0,Sigma0)
  t1.KS.n15.sims[i] <- biKS.stat( rbts  )
  t1.AD.n15.sims[i] <- AD.stat( rbts  )
  t1.CvM.n15.sims[i] <- CvM.stat( rbts  )
}
length(stats.t1[stats.t1>quantile(stats,probs=0.95)])/length(stats.t1)
}

